<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 3 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
		Link to GitHub repository: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
		
		<figure>
			<img src="cornell.png" alt="Cornell Boxes with Bunnies" style="width:70%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Part 1: Ray Generation and Scene Intersection</h2>
		In this section, I generated rays and created simple intersection methods for rays passing through a scene. 
		<p>
			Ray generation can be done by first taking the (x,y) coordinates of the corresponding point in image space and translating these coordinates 
			into camera space, where our camera is at the origin of the camera space and we have a sensor at the z=-1 plane. From this camera space point,
			we can generate a ray in camera space from the camera origin to the point, and then transform this into world space. This ray describes the path
			of light through the world, and these rays can then be used to sample colors at various points for pixels in our rendering. Taking a small square 
			of size 1 x 1 in image space, we can use Monte Carlo estimation to sample rays in this space and average their values to fill in the sample buffer with an estimated pixel value.
		</p>
		<p>
			Next, to find intersections of the ray with objects, I implemented ray-triangle and ray-sphere intersection methods. In specific, for ray-triangle intersection, 
			I used the Moller Trumbore algorithm, as shown here:
		</p>
		<figure>
			<img src="part1/mollertrumbore.png" alt="Moller Trumbore" style="width:70%"/>
			<figcaption>Source: Lecture 9/10 slides</figcaption>
		</figure>
		<p>
			Following this method, we can calculate t, b1, and b2 for any given ray and triangle. When t is greater than 0, and between the minimum possible and 
			maximum possible t value for the ray, there would be an intersection with the ray and the extended plane that the triangle lies on. To actually check 
			if the ray intersects with the triangle, we add an additional condition checking if b1 and b2 are positive and if b1 + b2 is less than 1. This is because 
			b1 and b2 are simply two of the barycentric coordinates if we were to solve for the barycentric coordinates of the intersection point, so having barycentric 
			coordinates that are positive and sum up to 1 is necessary for an intersection point to be within the triangle. 
		</p>
		<p>
			We can also find the ray-sphere intersection by solving a quadratic equation to find two values of t, representing the two intersections of the ray 
			with the sphere. We can take the smaller of the two t values (or the one that is valid if there is an invalid t value) and use that as the intersection point. 
		</p>

		<p>Below are a few examples of normal shading using the methods mentioned above. </p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part1/CBspheres.png" width="400px"/>
				  <figcaption>sky/CBspheres_lambertian.dae</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part1/CBgems.png" width="400px"/>
				  <figcaption>sky/CBgems.dae</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="part1/teapot.png" width="400px"/>
				  <figcaption>meshedit/teapot.dae</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part1/cube.png" width="400px"/>
				  <figcaption>simple/cube.dae</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Part 2: Bounding Volume Hierarchy</h2>
		To construct a BVH, I first created a bounding box enclosing all of the primitives within the given start and end iterators in construct_bvh. 
		While doing this, I keep track of the count of the number of primitives and also the centroids of all of the primitive bounding boxes. If the bounding box 
		holds more than max_leaf_size primitives, we know this is an inner node and will set the start and end iterators of this node. 
		<p>
			To get the start and end for the left and right children, I first calculate the average of the centroids. To choose how to split, I first looked for the longest axis by subtracting the max point and min point of the current 
			bounding box. Then, I partitioned the primitives within this bounding box into those with centroids less than the average of the centroids and those with centroids 
			greater than the average of the centroids. To prevent edge cases where infinite recursion may occur, I look for cases where the partition results in one side 
			of the partition being completely empty. If so, I add the closest primitive from the other side of the partition to the empty side of the partition. 
			Then, I set the left and right children by recursively constructing bvh's using the new start and end for the left and right children.
		</p>
		<p>
			If the bounding box holds no more than max_leaf_size, we just set the start and end of the node to be the inputted start and end. 
		</p>
		

		<h2>Part 3: Direct Illumination</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Part 4: Global Illumination</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Part 5: Adaptive Sampling</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Part 6: Extra Credit Opportunities</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
		
		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>